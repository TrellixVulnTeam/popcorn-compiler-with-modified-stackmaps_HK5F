--------
Overview
--------

This folder contains several useful scripts.  These are copied to the
installation folder by the installation script.  You can find more information
about using the scripts by running them with "-h".

1. Generating an LLVM/clang patch

The "gen-llvm-diff.sh" script will generate patches from the modified LLVM &
clang sources.  It creates a patch against the original checkout of the source,
and then checks to see if the generated patch is different from the patch
currently in the Popcorn compiler repository.  If so, it swaps out the old
patch with the new (and retains the old patch).

- To use the tool:

  $ gen-llvm-diff.sh -s <LLVM source>

2. Re-applying the Popcorn compiler patches to LLVM/clang

The "reapply-llvm-patch.sh" script will revert LLVM/clang source to the
original checkout, re-apply the patch in the Popcorn compiler repository and
re-install the compiler (if at any point it fails, it restores the source using
a backup).  This is useful in the case where new updates to the compiler patch
(e.g., new code pulled from the remote repository) need to be applied to
an existing installation.

- To use the tool:

  $ reapply-llvm-path.sh -s <LLVM source>

3. Checking alignment

The "check-align.py" script is useful for sanity checking symbol alignment in
multi-ISA binaries.  This can be useful for detecting when, for instance,
there's clashing symbols or symbols that can't be aligned with linker scripts.
The tool searches through the symbol tables to match symbols by name, and then
compare the virtual addresses at which they are placed.  It returns a non-zero
status when it finds a misalignment.

- To use the tool:

  $ check-align.py bin_aarch64 bin_x86-64

4. Parsing call chain information

If applications are built against the call information library (see
"lib/stack_depth/README" for more information), the library will dump call
statistics to a file ("stack_depth.dat" by default).  The "stack-depth-info.py"
script can be used to parse this file and print human-readable information.

- To use the tool:

  $ stack-depth-info.py -d stack_depth.dat

  This will print basic information including call stack depth, which functions
  were called, and how many times they were called.

- The default references functions by their address.  The script can also use
  the symbol table of the binary to convert function address to names:

  $ stack-depth-info.py -d stack-depth.dat -b <binary name>

- To print detailed call information, use the "-v" switch

5. Testing various points

There are several ways to migrate applications between architectures, depending
on how the migration library was built.  If the library was built with
migration triggering via environment variables (see "lib/migration/INSTALL" for
more information), the user can set a range of PCs at which the migration
library will trigger a migration.  When calling a migration point from within
this range of PCs, the migration library will initiate the procedure.  Rather
than having the user manually set these points, the "test-migration.py" script
can automate the process.  It also provides some functionality for methodically
testing migration at various points -- run the script with "-h" for more
information.

NOTE: the script has no way of knowing where migration points were inserted
into the application.  By default the script will parse the symbol table to
find all functions and will assume migration points were inserted at all of
them.  This is in general not correct, as it will include library functions.
Instead, a correct list of functions can be generated by generating call
information (see 2 above) and running the stack-depth-info.py script with "-f".

